<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/Code/MecaCell/MecaCell/connectablecell.hpp.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="potato">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #ffffff; background-color: #111111; }
body { font-family: monospace; color: #ffffff; background-color: #111111; }
* { font-size: 1em; }
.Function { color: #2edff2; }
.Statement { color: #baf046; font-weight: bold; }
.PreProc { color: #ff80ff; }
.Type { color: #ffbe57; font-weight: bold; }
.Number { color: #d51adb; }
.PreCondit { font-weight: bold; }
.Comment { color: #777777; }
.Constant { color: #d51adb; font-weight: bold; }
.Boolean { color: #d51adb; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="PreCondit">#ifndef CONNECTABLECELL_HPP</span>
#define CONNECTABLECELL_HPP
<span class="PreProc">#include </span>&lt;vector&gt;
<span class="PreProc">#include </span>&lt;sstream&gt;
<span class="PreProc">#include </span>&lt;cmath&gt;
<span class="PreProc">#include </span>&lt;cstdlib&gt;
<span class="PreProc">#include </span>&lt;iostream&gt;
<span class="PreProc">#include </span>&lt;memory&gt;
<span class="PreProc">#include </span>&quot;rotation.h&quot;
<span class="PreProc">#include </span>&quot;movable.h&quot;
<span class="PreProc">#include </span>&quot;orientable.h&quot;
<span class="PreProc">#include </span>&quot;connection.h&quot;

#define CUBICROOT2 <span class="Number">1.25992104989</span>
#define VOLUMEPI <span class="Number">0.23873241463</span>  <span class="Comment">// 1/(4/3*pi)</span>

<span class="Statement">using</span> <span class="Type">namespace</span> <span class="Constant">std</span>;

<span class="Type">namespace</span> MecaCell {
<span class="Type">template</span> &lt;<span class="Type">typename</span> Derived&gt; <span class="Type">class</span> ConnectableCell : <span class="Statement">public</span> Movable, <span class="Statement">public</span> Orientable {
 protected:
  <span class="Type">int</span> typeId = <span class="Number">0</span>;     <span class="Comment">// current cell type id. Used for determining adhesion</span>
  <span class="Type">bool</span> dead = <span class="Boolean">false</span>;  <span class="Comment">// is the cell dead or alive ?</span>
  <span class="Type">vector</span>&lt;<span class="Type">double</span>&gt; color = {<span class="Number">0.2</span>, <span class="Number">0.7</span>, <span class="Number">0.8</span>};
  <span class="Type">double</span> radius = DEFAULT_CELL_RADIUS;
  <span class="Type">double</span> baseRadius = DEFAULT_CELL_RADIUS;
  <span class="Type">double</span> stiffness = DEFAULT_CELL_STIFFNESS;
  <span class="Type">double</span> dampRatio = DEFAULT_CELL_DAMP_RATIO;
  <span class="Type">double</span> angularStiffness = DEFAULT_CELL_ANG_STIFFNESS;
  <span class="Type">bool</span> tested = <span class="Boolean">false</span>;  <span class="Comment">// has already been tested for collision</span>
  <span class="Type">vector</span>&lt;Connection&lt;Derived&gt;*&gt; connections;
  <span class="Type">vector</span>&lt;Derived*&gt; connectedCells;

 public:
  <span class="Function">ConnectableCell</span>(Vec pos) : <span class="Function">Movable</span>(pos) { <span class="Function">randomColor</span>(); }

  <span class="Function">ConnectableCell</span>(<span class="Type">const</span> Derived&amp; c, <span class="Type">const</span> Vec&amp; translation)
      : <span class="Function">Movable</span>(c.<span class="Function">getPosition</span>() + translation, c.mass), <span class="Function">radius</span>(c.radius) {
    <span class="Function">randomColor</span>();
  }

  <span class="Type">double</span> <span class="Function">getRadius</span>() <span class="Type">const</span> { <span class="Statement">return</span> radius; }
  <span class="Type">double</span> <span class="Function">getStiffness</span>() <span class="Type">const</span> { <span class="Statement">return</span> stiffness; }
  <span class="Type">double</span> <span class="Function">getColor</span>(<span class="Type">unsigned</span> <span class="Type">int</span> i) <span class="Type">const</span> {
    <span class="Statement">if</span> (i &lt; <span class="Number">3</span>) <span class="Statement">return</span> color[i];
    <span class="Statement">return</span> <span class="Number">0</span>;
  }
  <span class="Type">const</span> <span class="Constant">std</span>::<span class="Type">vector</span>&lt;Derived*&gt;&amp; <span class="Function">getConnectedCells</span>() <span class="Type">const</span> { <span class="Statement">return</span> connectedCells; }
  <span class="Type">double</span> <span class="Function">getPressure</span>() <span class="Type">const</span> {
    <span class="Type">double</span> surface = <span class="Number">4.0f</span> * <span class="Constant">M_PI</span> * radius * radius;
    <span class="Statement">return</span> totalForce / surface;
  }
  <span class="Type">double</span> <span class="Function">getNormalizedPressure</span>() <span class="Type">const</span> {
    <span class="Type">double</span> p = <span class="Function">getPressure</span>();
    <span class="Type">double</span> sign = p &gt;= <span class="Number">0</span> ? <span class="Number">1</span> : -<span class="Number">1</span>;
    <span class="Statement">return</span> <span class="Number">0.5</span> + sign * <span class="Number">0.5</span> * (<span class="Number">1.0</span> - <span class="Function">exp</span>(-<span class="Function">abs</span>(<span class="Number">14.0</span> * p)));
  }
  <span class="Type">double</span> <span class="Function">getSqradius</span>() <span class="Type">const</span> { <span class="Statement">return</span> radius * radius; }
  <span class="Type">bool</span> <span class="Function">alreadyTested</span>() <span class="Type">const</span> { <span class="Statement">return</span> tested; }

  <span class="Comment">/*</span><span class="Comment">*****************************</span>
<span class="Comment">   * main setters</span>
<span class="Comment">   ****************************</span><span class="Comment">*/</span>

  <span class="Type">void</span> <span class="Function">setRadius</span>(<span class="Type">double</span> r) { radius = r; }
  <span class="Type">void</span> <span class="Function">markAsTested</span>() { tested = <span class="Boolean">true</span>; }
  <span class="Type">void</span> <span class="Function">markAsNotTested</span>() { tested = <span class="Boolean">false</span>; }
  <span class="Type">double</span> <span class="Function">getBaseVolume</span>() { <span class="Statement">return</span> (<span class="Number">4.0</span> / <span class="Number">3.0</span>) * <span class="Constant">M_PI</span> * baseRadius * baseRadius * baseRadius; }
  <span class="Type">double</span> <span class="Function">getVolume</span>() { <span class="Statement">return</span> (<span class="Number">4.0</span> / <span class="Number">3.0</span>) * <span class="Constant">M_PI</span> * radius * radius * radius; }
  <span class="Type">double</span> <span class="Function">getRelativeVolume</span>() { <span class="Statement">return</span> <span class="Function">getVolume</span>() / <span class="Function">getBaseVolume</span>(); }

  <span class="Comment">// return the connection length with another cell</span>
  <span class="Comment">// according to an adhesion coef (0 &lt;= adh &lt;= 1)</span>
  <span class="Type">double</span> <span class="Function">getConnectionLength</span>(<span class="Type">const</span> Derived* c, <span class="Type">const</span> <span class="Type">double</span> adh) {
    <span class="Type">double</span> l = radius + c-&gt;radius;
    <span class="Statement">return</span> <span class="Function">getConnectionLength</span>(l, adh);
  }

  <span class="Type">static</span> <span class="Type">double</span> <span class="Function">getConnectionLength</span>(<span class="Type">const</span> <span class="Type">double</span> l, <span class="Type">const</span> <span class="Type">double</span> adh) {
    <span class="Statement">if</span> (adh &gt; ADH_THRESHOLD) <span class="Statement">return</span> <span class="Function">mix</span>(MAX_CELL_ADH_LENGTH * l, MIN_CELL_ADH_LENGTH * l, adh);
    <span class="Statement">return</span> l;
  }

  Derived* <span class="Function">selfptr</span>() { <span class="Statement">return</span> <span class="Statement">static_cast</span>&lt;Derived *&gt;(<span class="Statement">this</span>); }
  Derived&amp; <span class="Function">self</span>() { <span class="Statement">return</span> <span class="Statement">static_cast</span>&lt;Derived &amp;&gt;(*<span class="Statement">this</span>); }
  <span class="Type">const</span> Derived&amp; <span class="Function">selfconst</span>() <span class="Type">const</span> { <span class="Statement">return</span> <span class="Statement">static_cast</span>&lt;<span class="Type">const</span> Derived &amp; &gt;(*<span class="Statement">this</span>); }

  <span class="Comment">// Don't forget to implement this method in the derived class</span>
  <span class="Type">double</span> <span class="Function">getAdhesionWith</span>(<span class="Type">const</span> <span class="Type">int</span> tId) <span class="Type">const</span> { <span class="Statement">return</span> <span class="Function">selfconst</span>().<span class="Function">getAdhesionWith</span>(tId); }

  <span class="Type">vector</span>&lt;Connection&lt;Derived&gt;*&gt;&amp; <span class="Function">getRWConnections</span>() { <span class="Statement">return</span> connections;}

  <span class="Comment">/*</span><span class="Comment">*****************************</span>
<span class="Comment">   * connections</span>
<span class="Comment">   ****************************</span><span class="Comment">*/</span>
  Connection&lt;Derived&gt;* <span class="Function">connection</span>(Derived* c) {
    <span class="Statement">if</span> (c != <span class="Statement">this</span>) {
      Vec AB = c-&gt;position - position;
      <span class="Type">double</span> sqdist = AB.<span class="Function">sqlength</span>();
      <span class="Type">double</span> sql = radius + c-&gt;radius;
      sql *= sql;
      <span class="Statement">if</span> (sqdist &lt;= sql) {
        <span class="Comment">// if those cells aren't already connected</span>
        <span class="Statement">if</span> (<span class="Function">find</span>(connectedCells.<span class="Function">begin</span>(), connectedCells.<span class="Function">end</span>(), c) == connectedCells.<span class="Function">end</span>()) {
          <span class="Comment">// first we check if this connection would not go through an already connected cell</span>
          <span class="Type">bool</span> ok = <span class="Boolean">true</span>;
          Vec ABn = AB.<span class="Function">normalized</span>();
          <span class="Statement">for</span> (<span class="Type">auto</span> c1It = connections.<span class="Function">begin</span>(); c1It != connections.<span class="Function">end</span>(); ++c1It) {
            <span class="Type">auto</span> c1 = *c1It;
            Vec c1Vec;
            <span class="Type">double</span> r1;
            <span class="Type">double</span> c1L = c1-&gt;<span class="Function">getLength</span>();
            <span class="Statement">if</span> (c1-&gt;<span class="Function">getNode0</span>() == <span class="Statement">this</span>) {
              c1Vec = c1-&gt;<span class="Function">getDirection</span>() * c1L;
              r1 = c1-&gt;<span class="Function">getNode1</span>()-&gt;<span class="Function">getRadius</span>();
            } <span class="Statement">else</span> {
              c1Vec = -c1-&gt;<span class="Function">getDirection</span>() * c1L;
              r1 = c1-&gt;<span class="Function">getNode0</span>()-&gt;<span class="Function">getRadius</span>();
            }
            <span class="Type">double</span> scal = c1Vec.<span class="Function">dot</span>(ABn);
            c1L *= c1L;
            <span class="Statement">if</span> (scal &gt; <span class="Number">0</span> &amp;&amp; c1L &lt; sqdist &amp;&amp; c1L - scal * scal &lt; r1 * r1) {
              ok = <span class="Boolean">false</span>;
              <span class="Statement">break</span>;
            }
          }
          <span class="Statement">if</span> (ok) {
            <span class="Type">double</span> adh0 = <span class="Function">getAdhesionWith</span>(c-&gt;typeId);
            <span class="Type">double</span> adh1 = c-&gt;<span class="Function">getAdhesionWith</span>(typeId);
            <span class="Type">double</span> minAdh = (adh0 + adh1) * <span class="Number">0.5</span>;
            <span class="Type">double</span> l = <span class="Function">getConnectionLength</span>(c, minAdh);
            <span class="Type">double</span> k = (stiffness * radius + c-&gt;stiffness * c-&gt;radius) / (radius + c-&gt;radius);
            <span class="Type">double</span> dr = (dampRatio * radius + c-&gt;dampRatio * c-&gt;radius) / (radius + c-&gt;radius);
            <span class="Type">double</span> maxTeta = <span class="Function">mix</span>(<span class="Number">0.0</span>, <span class="Constant">M_PI</span>, minAdh);
            Connection&lt;Derived&gt;* s = <span class="Statement">new</span> Connection&lt;Derived&gt;(
                <span class="Type">pair</span>&lt;Derived*,Derived*&gt;(<span class="Function">selfptr</span>(), c), <span class="Function">Spring</span>(k, <span class="Function">dampingFromRatio</span>(dr, mass + c-&gt;mass, k), l),
                <span class="Function">make_pair</span>(<span class="Function">Joint</span>(<span class="Function">getAngularStiffness</span>(),
                                <span class="Function">dampingFromRatio</span>(dr, <span class="Function">getMomentOfInertia</span>(), angularStiffness), maxTeta),
                          <span class="Function">Joint</span>(<span class="Function">getAngularStiffness</span>(),
                                <span class="Function">dampingFromRatio</span>(dr, c-&gt;<span class="Function">getMomentOfInertia</span>(), c-&gt;angularStiffness), maxTeta)),
                <span class="Function">make_pair</span>(
                    <span class="Function">Joint</span>(<span class="Function">getAngularStiffness</span>(), <span class="Function">dampingFromRatio</span>(dr, <span class="Function">getMomentOfInertia</span>(), angularStiffness),
                          maxTeta),
                    <span class="Function">Joint</span>(<span class="Function">getAngularStiffness</span>(),
                          <span class="Function">dampingFromRatio</span>(dr, c-&gt;<span class="Function">getMomentOfInertia</span>(), c-&gt;angularStiffness), maxTeta)));
            <span class="Function">addConnection</span>(c, s);
            <span class="Statement">return</span> s;
          }
        }
      }
    }
    <span class="Statement">return</span> <span class="Constant">NULL</span>;
  }

  <span class="Type">double</span> <span class="Function">getMomentOfInertia</span>() <span class="Type">const</span> { <span class="Statement">return</span> <span class="Number">0.4</span> * mass * radius * radius; }
  <span class="Type">double</span> <span class="Function">getAngularStiffness</span>() <span class="Type">const</span> { <span class="Statement">return</span> angularStiffness; }

  <span class="Type">void</span> <span class="Function">updateAllConnections</span>() {
    <span class="Comment">// for (unsigned int i = 0; i &lt; connections.size(); i++) {</span>
    <span class="Comment">// Connection&lt;Derived&gt;* co = connections[i];</span>
    <span class="Comment">// int otherId = co-&gt;getNode(0)-&gt;getParent() == this ? 1 : 0;</span>
    <span class="Comment">// Cell* otherCell = co-&gt;getNode(otherId)-&gt;getParent();</span>
    <span class="Comment">// double adh1 = 0;</span>
    <span class="Comment">// double adh0 = 0;</span>
    <span class="Comment">// double otherRadius = 0;</span>
    <span class="Comment">// if (otherCell != nullptr) {</span>
    <span class="Comment">// adh1 = otherCell-&gt;getCurrentState().getAdhesionWith(getCurrentState().getId());</span>
    <span class="Comment">// otherRadius = otherCell-&gt;getRadius();</span>
    <span class="Comment">// adh0 = getCurrentState().getAdhesionWith(otherCell-&gt;getCurrentState().getId());</span>
    <span class="Comment">//} else {</span>
    <span class="Comment">// adh1 = getCurrentState().getWallAdhesion();</span>
    <span class="Comment">// adh0 = adh1;</span>
    <span class="Comment">//}</span>
    <span class="Comment">// double minAdh = adh0 &lt; adh1 ? adh0 : adh1;</span>
    <span class="Comment">// co-&gt;ls.l = getConnectionLength(getRadius() + otherRadius, minAdh);</span>
    <span class="Comment">//}</span>
  }

  <span class="Type">void</span> <span class="Function">addConnection</span>(Derived* c, Connection&lt;Derived&gt;* s) {
    connections.<span class="Function">push_back</span>(s);
    c-&gt;connections.<span class="Function">push_back</span>(s);
    connectedCells.<span class="Function">push_back</span>(c);
    c-&gt;connectedCells.<span class="Function">push_back</span>(<span class="Function">selfptr</span>());
  }

  <span class="Type">void</span> <span class="Function">eraseCell</span>(Derived* cell) {
    <span class="Type">unsigned</span> <span class="Type">int</span> prevC = connectedCells.<span class="Function">size</span>();
    connectedCells.<span class="Function">erase</span>(<span class="Function">remove</span>(connectedCells.<span class="Function">begin</span>(), connectedCells.<span class="Function">end</span>(), cell), connectedCells.<span class="Function">end</span>());
    <span class="Function">assert</span>(connectedCells.<span class="Function">size</span>() == prevC - <span class="Number">1</span> || prevC == <span class="Number">0</span>);
  }

  <span class="Type">void</span> <span class="Function">deleteConnection</span>(Derived* c) {
    Connection&lt;Derived&gt;* s = <span class="Constant">nullptr</span>;
    <span class="Statement">for</span> (<span class="Type">unsigned</span> <span class="Type">int</span> i = <span class="Number">0</span>; i &lt; connections.<span class="Function">size</span>(); i++) {
      Connection&lt;Derived&gt;* co = connections[i];
      <span class="Statement">if</span> ((co-&gt;<span class="Function">getNode1</span>() == <span class="Statement">this</span> &amp;&amp; co-&gt;<span class="Function">getNode0</span>() == c) ||
          (co-&gt;<span class="Function">getNode1</span>() == c &amp;&amp; co-&gt;<span class="Function">getNode0</span>() == <span class="Statement">this</span>)) {
        s = co;
        <span class="Statement">break</span>;
      }
    }
    <span class="Function">deleteConnection</span>(c, s);
  }

  <span class="Type">void</span> <span class="Function">deleteConnection</span>(Derived* c, Connection&lt;Derived&gt;* s) {
    <span class="Function">assert</span>(c != <span class="Constant">nullptr</span>);
    <span class="Function">eraseCell</span>(c);
    c-&gt;<span class="Function">eraseCell</span>(<span class="Function">selfptr</span>());
    <span class="Function">eraseConnection</span>(s);
    c-&gt;<span class="Function">eraseConnection</span>(s);
  }

  <span class="Type">void</span> <span class="Function">eraseConnection</span>(Connection&lt;Derived&gt;* s) {
      connections.<span class="Function">erase</span>(<span class="Function">remove</span>(connections.<span class="Function">begin</span>(), connections.<span class="Function">end</span>(), s), connections.<span class="Function">end</span>());
  }

  <span class="Type">void</span> <span class="Function">eraseAndDeleteAllConnections</span>(<span class="Type">vector</span>&lt;Connection&lt;Derived&gt;*&gt;&amp; aux) {
    <span class="Statement">for</span> (<span class="Type">auto</span> cIt = connections.<span class="Function">begin</span>(); cIt != connections.<span class="Function">end</span>();) {
      Connection&lt;Derived&gt;* sp = *cIt;
      <span class="Type">auto</span> otherCell =
          sp-&gt;<span class="Function">getNode0</span>() == <span class="Statement">this</span> ? sp-&gt;<span class="Function">getNode1</span>() : sp-&gt;<span class="Function">getNode0</span>();
      <span class="Statement">if</span> (otherCell != <span class="Constant">nullptr</span>) {
        aux.<span class="Function">erase</span>(<span class="Function">remove</span>(aux.<span class="Function">begin</span>(), aux.<span class="Function">end</span>(), sp), aux.<span class="Function">end</span>());
        connectedCells.<span class="Function">erase</span>(<span class="Function">remove</span>(connectedCells.<span class="Function">begin</span>(), connectedCells.<span class="Function">end</span>(), otherCell),
                             connectedCells.<span class="Function">end</span>());
        otherCell-&gt;connectedCells.<span class="Function">erase</span>(
            <span class="Function">remove</span>(otherCell-&gt;connectedCells.<span class="Function">begin</span>(), otherCell-&gt;connectedCells.<span class="Function">end</span>(), <span class="Statement">this</span>),
            otherCell-&gt;connectedCells.<span class="Function">end</span>());
        otherCell-&gt;<span class="Function">eraseConnection</span>(sp);
        cIt = connections.<span class="Function">erase</span>(cIt);
        <span class="Statement">delete</span> sp;
      } <span class="Statement">else</span> {
        ++cIt;
      }
    }
  }

  <span class="Comment">/*</span><span class="Comment">*****************************</span>
<span class="Comment">   * division and control</span>
<span class="Comment">   ****************************</span><span class="Comment">*/</span>

  Derived* <span class="Function">updateBehavior</span>(<span class="Type">double</span> dt) { <span class="Statement">return</span> <span class="Function">self</span>().<span class="Function">updateBehavior</span>(dt); }

  <span class="Type">void</span> <span class="Function">die</span>() { dead = <span class="Boolean">true</span>; }
  <span class="Type">bool</span> <span class="Function">isDead</span>() { <span class="Statement">return</span> dead; }

  <span class="Type">void</span> <span class="Function">randomColor</span>() {
    <span class="Type">double</span> r0 = <span class="Number">0.001</span> * (<span class="Function">rand</span>() % <span class="Number">1000</span>);
    <span class="Type">double</span> r1 = <span class="Number">0.001</span> * (<span class="Function">rand</span>() % <span class="Number">1000</span>);
    <span class="Statement">if</span> (r0 &lt; <span class="Number">0.5</span>) {
      color[<span class="Number">1</span>] = <span class="Number">0.1</span> * r1;
      color[<span class="Number">2</span>] = <span class="Number">0.65</span> + (<span class="Number">0.2</span> * r0);
      color[<span class="Number">0</span>] = <span class="Number">0.8</span> + (<span class="Number">0.2</span> * r1);
    } <span class="Statement">else</span> {
      color[<span class="Number">0</span>] = <span class="Number">0.1</span> * r1;
      color[<span class="Number">1</span>] = <span class="Number">0.65</span> + (<span class="Number">0.2</span> * r0);
      color[<span class="Number">2</span>] = <span class="Number">0.8</span> + (<span class="Number">0.2</span> * r1);
    }
  }
};
}

<span class="PreCondit">#endif</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
